var documenterSearchIndex = {"docs":
[{"location":"#FilePathsBase.jl-1","page":"Home","title":"FilePathsBase.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Build status) (Image: codecov.io) (Image: ) (Image: )","category":"page"},{"location":"#","page":"Home","title":"Home","text":"FilePathsBase.jl provides a type based approach to working with filesystem paths in julia.","category":"page"},{"location":"#Intallation-1","page":"Home","title":"Intallation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"FilePathsBase.jl is registered, so you can to use Pkg.add to install it.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> Pkg.add(\"FilePathsBase\")","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> using FilePathsBase","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The first important difference about working with paths in FilePathsBase.jl is that path segments are represented as an immutable tuple of strings.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Path creation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> Path(\"~/repos/FilePathsBase.jl/\")\np\"~/repos/FilePathsBase.jl/\"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p\"~/repos/FilePathsBase.jl/\"\np\"~/repos/FilePathsBase.jl/\"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Human readable file status info:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> stat(p\"README.md\")\nStatus(\n  device = 16777220,\n  inode = 48428965,\n  mode = -rw-r--r--,\n  nlink = 1,\n  uid = 501,\n  gid = 20,\n  rdev = 0,\n  size = 1880 (1.8K),\n  blksize = 4096 (4.0K),\n  blocks = 8,\n  mtime = 2016-02-16T00:49:27,\n  ctime = 2016-02-16T00:49:27,\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Working with permissions:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> m = mode(p\"README.md\")\n-rw-r--r--\n\njulia> m - readable(:ALL)\n--w-------\n\njulia> m + executable(:ALL)\n-rwxr-xr-x\n\njulia> chmod(p\"README.md\", \"+x\")\n\njulia> mode(p\"README.md\")\n-rwxr-xr-x\n\njulia> chmod(p\"README.md\", m)\n\njulia> m = mode(p\"README.md\")\n-rw-r--r--\n\njulia> chmod(p\"README.md\", user=(READ+WRITE+EXEC), group=(READ+WRITE), other=READ)\n\njulia> mode(p\"README.md\")\n-rwxrw-r--\n","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Reading and writing directly to file paths:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> write(p\"testfile\", \"foobar\")\n6\n\njulia> read(p\"testfile\")\n\"foobar\"","category":"page"},{"location":"#API-1","page":"Home","title":"API","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"All the standard methods for working with paths in base julia exist in the FilePathsBase.jl. The following describes the rough mapping of method names. Use ? at the REPL to get the documentation and arguments as they may be different than the base implementations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Base FilePathsBase.jl\n\"/home/user/docs\" p\"/home/user/docs\"\nN/A Path()\npwd() pwd(::Type{<:AbstractPath}) (or cwd())\nhomedir() homedir(::Type{<:AbstractPath}) (or home())\ncd() cd()\njoinpath() joinpath(), join, /\nbasename() basename()\nN/A hasparent, parents, parent\nsplitext splitext\nN/A filename\nN/A extension\nN/A extensions\nispath exists\nrealpath real\nnormpath norm\nabspath abs\nrelpath relative\nstat stat\nlstat lstat\nfilemode mode\nmtime modified\nctime created\nisdir isdir\nisfile isfile\nislink islink\nissocket issocket\nisfifo isfifo\nischardev ischardev\nisblockdev isblockdev\nisexecutable (deprecated) isexecutable\niswritable (deprecated) iswritable\nisreadable (deprecated) isreadable\nismount ismount\nisabspath isabs\nsplitdrive()[1] drive\nN/A root (property)\nsplit(p, \"/\") segments (property)\nexpanduser expanduser\nmkdir mkdir\nmkpath N/A (use mkdir)\nsymlink symlink\ncp cp\nmv mv\ndownload download\nreaddir readdir\nN/A readpath\nN/A walkpath\nrm rm\ntouch touch\ntempname() tempname(::Type{<:AbstractPath}) (or tmpname)\ntempdir() tempdir(::Type{<:AbstractPath}) (or tmpdir)\nmktemp() mktemp(::Type{<:AbstractPath}) (or mktmp)\nmktempdir() mktempdir(::Type{<:AbstractPath}) (or mktmpdir)\nchmod chmod (recursive unix-only)\nchown (unix only) chown (unix only)\nread read\nwrite write\n@DIR @PATH\n@FILE @FILEPATH","category":"page"},{"location":"#","page":"Home","title":"Home","text":"FilePathsBase.AbstractPath\nFilePathsBase.Path\nFilePathsBase.SystemPath\nFilePathsBase.PosixPath\nFilePathsBase.WindowsPath\nFilePathsBase.Mode\nFilePathsBase.@p_str\nFilePathsBase.@__PATH__\nFilePathsBase.@__FILEPATH__\nFilePathsBase.@LOCAL\nFilePathsBase.cwd\nFilePathsBase.home\nFilePathsBase.hasparent\nFilePathsBase.parents\nFilePathsBase.parent\nBase.:(*)(::P, ::Union{P, AbstractString, Char}...) where P <: AbstractPath\nBase.:(/)(::AbstractPath, ::Union{AbstractPath, AbstractString}...)\nBase.join(::T, ::Union{AbstractPath, AbstractString}...) where T <: AbstractPath\nFilePathsBase.filename(::AbstractPath)\nFilePathsBase.extension(::AbstractPath)\nFilePathsBase.extensions(::AbstractPath)\nBase.isempty(::AbstractPath)\nLinearAlgebra.norm(::T) where {T <: AbstractPath}\nBase.abs(::AbstractPath)\nFilePathsBase.isabs(::AbstractPath)\nFilePathsBase.relative(::T, ::T) where {T <: AbstractPath}\nBase.real(::AbstractPath)\nFilePathsBase.mode(::AbstractPath)\nFilePathsBase.modified(::AbstractPath)\nFilePathsBase.created(::AbstractPath)\nFilePathsBase.isexecutable\nBase.iswritable(::PosixPath)\nBase.isreadable(::PosixPath)\nBase.cp(::AbstractPath, ::AbstractPath)\nBase.mv(::AbstractPath, ::AbstractPath)\nBase.download(::AbstractString, ::AbstractPath)\nFilePathsBase.readpath\nFilePathsBase.walkpath\nBase.open(::AbstractPath)\nFilePathsBase.tmpname\nFilePathsBase.tmpdir\nFilePathsBase.mktmp\nFilePathsBase.mktmpdir\nBase.chown(::PosixPath, ::AbstractString, ::AbstractString)\nBase.chmod(::PosixPath, ::Mode)\nFilePathsBase.TestPaths\nFilePathsBase.TestPaths.PathSet","category":"page"},{"location":"#FilePathsBase.AbstractPath","page":"Home","title":"FilePathsBase.AbstractPath","text":"AbstractPath\n\nDefines an abstract filesystem path.\n\nProperties\n\nsegments::Tuple{Vararg{String}} - path segments (required)\nroot::String - path root (defaults to \"/\")\ndrive::String - path drive (defaults to \"\")\nseparator::String - path separator (defaults to \"/\")\n\nRequired Methods\n\nT(str::String) - A string constructor\nFilePathsBase.ispathtype(::Type{T}, x::AbstractString) = true\nread(path::T)\nwrite(path::T, data)\nexists(path::T - whether the path exists\nstat(path::T) - File status describing permissions, size and creation/modified times\nmkdir(path::T; kwargs...) - Create a new directory\nrm(path::T; kwags...) - Remove a file or directory\nreaddir(path::T) - Scan all files and directories at a specific path level\n\n\n\n\n\n","category":"type"},{"location":"#FilePathsBase.Path","page":"Home","title":"FilePathsBase.Path","text":"Path() -> SystemPath\nPath(fp::Tuple) -> SystemPath\nPath(fp::P) where P <: AbstractPath) -> P\nPath(fp::AbstractString) -> AbstractPath\nPath(fp::P, segments::Tuple) -> P\n\nResponsible for creating the appropriate platform specific path (e.g., PosixPath and WindowsPath` for Unix and Windows systems respectively)\n\nNOTE: Path(::AbstractString) can also work for custom paths if ispathtype is defined for that type.\n\n\n\n\n\n","category":"function"},{"location":"#FilePathsBase.SystemPath","page":"Home","title":"FilePathsBase.SystemPath","text":"SystemPath\n\nA union of PosixPath and WindowsPath which is used for writing methods that wrap base functionality.\n\n\n\n\n\n","category":"constant"},{"location":"#FilePathsBase.PosixPath","page":"Home","title":"FilePathsBase.PosixPath","text":"PosixPath()\nPosixPath(str)\n\nRepresents any posix path (e.g., /home/user/docs)\n\n\n\n\n\n","category":"type"},{"location":"#FilePathsBase.WindowsPath","page":"Home","title":"FilePathsBase.WindowsPath","text":"WindowsPath()\nWindowsPath(str)\n\nRepresents a windows path (e.g., C:\\User\\Documents)\n\n\n\n\n\n","category":"type"},{"location":"#FilePathsBase.Mode","page":"Home","title":"FilePathsBase.Mode","text":"Mode(m::UInt8)\nMode(;user::UInt8=0o0, group::UInt8=0o0, other::UInt8=0o0)\nMode(mode::UInt8, usr_grps::Symbol...)\nMode(str)\n\nProvides an abstraction for working with posix file permissions. A lot of the low level permissions code for this type was below and the corresponding constants have been translated from cpython's Lib/stat.py.\n\nExamples\n\njulia> Mode(\"-rwxr-x--x\")\n-rwxr-x--x\n\n\n\n\n\n","category":"type"},{"location":"#FilePathsBase.@p_str","page":"Home","title":"FilePathsBase.@p_str","text":"@p_str -> Path\n\nConstructs a Path (platform specific subtype of AbstractPath), such as p\"~/.juliarc.jl\".\n\n\n\n\n\n","category":"macro"},{"location":"#FilePathsBase.@__PATH__","page":"Home","title":"FilePathsBase.@__PATH__","text":"@__PATH__ -> SystemPath\n\n@PATH expands to a path with the directory part of the absolute path of the file containing the macro. Returns an empty Path if run from a REPL or if evaluated by julia -e <expr>.\n\n\n\n\n\n","category":"macro"},{"location":"#FilePathsBase.@__FILEPATH__","page":"Home","title":"FilePathsBase.@__FILEPATH__","text":"@__FILEPATH__ -> SystemPath\n\n@FILEPATH expands to a path with the absolute file path of the file containing the macro. Returns an empty Path if run from a REPL or if evaluated by julia -e <expr>.\n\n\n\n\n\n","category":"macro"},{"location":"#FilePathsBase.@LOCAL","page":"Home","title":"FilePathsBase.@LOCAL","text":"@LOCAL(filespec)\n\nConstruct an absolute path to filespec relative to the source file containing the macro call.\n\n\n\n\n\n","category":"macro"},{"location":"#FilePathsBase.cwd","page":"Home","title":"FilePathsBase.cwd","text":"  cwd() -> SystemPath\n\nGet the current working directory.\n\nExamples\n\njulia> cwd()\np\"/home/JuliaUser\"\n\njulia> cd(p\"/home/JuliaUser/Projects/julia\")\n\njulia> cwd()\np\"/home/JuliaUser/Projects/julia\"\n\n\n\n\n\n","category":"function"},{"location":"#FilePathsBase.hasparent","page":"Home","title":"FilePathsBase.hasparent","text":"hasparent(fp::AbstractPath) -> Bool\n\nReturns whether there is a parent directory component to the supplied path.\n\n\n\n\n\n","category":"function"},{"location":"#FilePathsBase.parents","page":"Home","title":"FilePathsBase.parents","text":"parents{T<:AbstractPath}(fp::T) -> Array{T}\n\nReturn all parents of the path. If no parent exists then either \"/\" or \".\" will be returned depending on whether the path is absolute.\n\nExample\n\n``` julia> parents(p\"~/.julia/v0.6/REQUIRE\") 3-element Array{FilePathsBase.PosixPath,1}:  p\"~\"  p\"~/.julia\"  p\"~/.julia/v0.6\"\n\njulia> parents(p\"/etc\") 1-element Array{PosixPath,1}:  p\"/\"\n\njulia> parents(p\"etc\") 1-element Array{PosixPath,1}:  p\".\"\n\njulia> parents(p\".\") 1-element Array{PosixPath,1}:  p\".\"  ```\n\n\n\n\n\n","category":"function"},{"location":"#Base.parent","page":"Home","title":"Base.parent","text":"parent{T<:AbstractPath}(fp::T) -> T\n\nReturns the parent of the supplied path. If no parent exists then either \"/\" or \".\" will be returned depending on whether the path is absolute.\n\nExample\n\njulia> parent(p\"~/.julia/v0.6/REQUIRE\")\np\"~/.julia/v0.6\"\n\njulia> parent(p\"/etc\")\np\"/\"\n\njulia> parent(p\"etc\")\np\".\"\n\njulia> parent(p\".\")\np\".\"\n\n\n\n\n\n","category":"function"},{"location":"#Base.:*-Union{Tuple{P}, Tuple{P,Vararg{Union{Char, AbstractString, P},N} where N}} where P<:AbstractPath","page":"Home","title":"Base.:*","text":"*(a::T, b::Union{T, AbstractString, AbstractChar}...) where {T <: AbstractPath} -> T\n\nConcatenate paths, strings and/or characters, producing a new path. This is equivalent to concatenating the string representations of paths and other strings and then constructing a new path.\n\nExample\n\njulia> p\"foo\" * \"bar\"\np\"foobar\"\n\n\n\n\n\n","category":"method"},{"location":"#Base.:/-Tuple{AbstractPath,Vararg{Union{AbstractString, AbstractPath},N} where N}","page":"Home","title":"Base.:/","text":"/(a::AbstractPath, b::Union{AbstractPath, AbstractString}...) -> AbstractPath\n\nJoin the path components into a new fulll path, equivalent to calling joinpath\n\nExample\n\njulia> p\"foo\" / \"bar\"\np\"foo/bar\"\n\njulia> p\"foo\" / \"bar\" / \"baz\"\np\"foo/bar/baz\"\n\n\n\n\n\n","category":"method"},{"location":"#Base.join-Union{Tuple{T}, Tuple{T,Vararg{Union{AbstractString, AbstractPath},N} where N}} where T<:AbstractPath","page":"Home","title":"Base.join","text":"join(root::AbstractPath, pieces::Union{AbstractPath, AbstractString}...) -> AbstractPath\n\nJoins path components into a full path.\n\nExample\n\njulia> join(p\"~/.julia/v0.6\", \"REQUIRE\")\np\"~/.julia/v0.6/REQUIRE\"\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.filename-Tuple{AbstractPath}","page":"Home","title":"FilePathsBase.filename","text":"filename(fp::AbstractPath) -> AbstractString\n\nExtracts the basename without any extensions.\n\nExample\n\njulia> filename(p\"~/repos/FilePathsBase.jl/src/FilePathsBase.jl\")\n\"FilePathsBase\"\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.extension-Tuple{AbstractPath}","page":"Home","title":"FilePathsBase.extension","text":"extension(fp::AbstractPath) -> AbstractString\n\nExtracts the last extension from a filename if there any, otherwise it returns an empty string.\n\nExample\n\njulia> extension(p\"~/repos/FilePathsBase.jl/src/FilePathsBase.jl\")\n\"jl\"\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.extensions-Tuple{AbstractPath}","page":"Home","title":"FilePathsBase.extensions","text":"extensions(fp::AbstractPath) -> AbstractString\n\nExtracts all extensions from a filename if there any, otherwise it returns an empty string.\n\nExample\n\njulia> extensions(p\"~/repos/FilePathsBase.jl/src/FilePathsBase.jl.bak\")\n2-element Array{SubString{String},1}:\n \"jl\"\n \"bak\"\n\n\n\n\n\n","category":"method"},{"location":"#Base.isempty-Tuple{AbstractPath}","page":"Home","title":"Base.isempty","text":"isempty(fp::AbstractPath) -> Bool\n\nReturns whether or not a path is empty.\n\nNOTE: Empty paths are usually only created by Path(), as p\"\" and Path(\"\") will default to using the current directory (or p\".\").\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm-Union{Tuple{T}, Tuple{T}} where T<:AbstractPath","page":"Home","title":"LinearAlgebra.norm","text":"norm(fp::AbstractPath) -> AbstractPath\n\nNormalizes a path by removing \".\" and \"..\" entries.\n\n\n\n\n\n","category":"method"},{"location":"#Base.abs-Tuple{AbstractPath}","page":"Home","title":"Base.abs","text":"abs(fp::AbstractPath) -> AbstractPath\n\nCreates an absolute path by adding the current working directory if necessary.\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.relative-Union{Tuple{T}, Tuple{T,T}} where T<:AbstractPath","page":"Home","title":"FilePathsBase.relative","text":"relative{T<:AbstractPath}(fp::T, start::T=T(\".\"))\n\nCreates a relative path from either the current directory or an arbitrary start directory.\n\n\n\n\n\n","category":"method"},{"location":"#Base.real-Tuple{AbstractPath}","page":"Home","title":"Base.real","text":"real(path::AbstractPath) -> AbstractPath\n\nCanonicalize a path by expanding symbolic links and removing \".\" and \"..\" entries.\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.mode-Tuple{AbstractPath}","page":"Home","title":"FilePathsBase.mode","text":"mode(fp::AbstractPath) -> Mode\n\nReturns the Mode for the specified path.\n\nExample\n\njulia> mode(p\"src/FilePathsBase.jl\")\n-rw-r--r--\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.modified-Tuple{AbstractPath}","page":"Home","title":"FilePathsBase.modified","text":"modified(fp::AbstractPath) -> DateTime\n\nReturns the last modified date for the path.\n\nExample\n\njulia> modified(p\"src/FilePathsBase.jl\")\n2017-06-20T04:01:09\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.created-Tuple{AbstractPath}","page":"Home","title":"FilePathsBase.created","text":"created(fp::AbstractPath) -> DateTime\n\nReturns the creation date for the path.\n\nExample\n\njulia> created(p\"src/FilePathsBase.jl\")\n2017-06-20T04:01:09\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.isexecutable","page":"Home","title":"FilePathsBase.isexecutable","text":"isexecutable(fp::SystemPath) -> Bool\n\nReturns whether the path is executable for the current user.\n\n\n\n\n\n","category":"function"},{"location":"#Base.iswritable-Tuple{PosixPath}","page":"Home","title":"Base.iswritable","text":"iswritable(fp::AbstractPath) -> Bool\n\nReturns whether the path is writable for the current user.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isreadable-Tuple{PosixPath}","page":"Home","title":"Base.isreadable","text":"isreadable(fp::SystemPath) -> Bool\n\nReturns whether the path is readable for the current user.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Filesystem.cp-Tuple{AbstractPath,AbstractPath}","page":"Home","title":"Base.Filesystem.cp","text":"cp(src::AbstractPath, dst::AbstractPath; force=false, follow_symlinks=false)\n\nCopy the file or directory from src to dst. An existing dst will only be overwritten if force=true. If the path types support symlinks then follow_symlinks=true will copy the contents of the symlink to the destination.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Filesystem.mv-Tuple{AbstractPath,AbstractPath}","page":"Home","title":"Base.Filesystem.mv","text":"mv(src::AbstractPath, dst::AbstractPath; force=false)\n\nMove the file or director from src to dst. An exist dst will only be overwritten if force=true.\n\n\n\n\n\n","category":"method"},{"location":"#Base.download-Tuple{AbstractString,AbstractPath}","page":"Home","title":"Base.download","text":"download(url::Union{AbstractString, AbstractPath}, localfile::AbstractPath)\n\nDownload a file from the remote url and save it to the localfile path.\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.readpath","page":"Home","title":"FilePathsBase.readpath","text":"readpath(fp::P) where {P <: AbstractPath} -> Vector{P}\n\n\n\n\n\n","category":"function"},{"location":"#FilePathsBase.walkpath","page":"Home","title":"FilePathsBase.walkpath","text":"walkpath(fp::AbstractPath; topdown=true, follow_symlinks=false, onerror=throw)\n\nPerforms a depth first search through the directory structure\n\n\n\n\n\n","category":"function"},{"location":"#Base.open-Tuple{AbstractPath}","page":"Home","title":"Base.open","text":"open(filename::AbstractPath; keywords...) -> FileBuffer   open(filename::AbstractPath, mode=\"r) -> FileBuffer\n\nReturn a default FileBuffer for open calls to paths which only support read and write methods. See base open docs for details on valid keywords.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Filesystem.chown-Tuple{PosixPath,AbstractString,AbstractString}","page":"Home","title":"Base.Filesystem.chown","text":"chown(fp::SystemPath, user::AbstractString, group::AbstractString; recursive=false)\n\nChange the user and group of the fp.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Filesystem.chmod-Tuple{PosixPath,Mode}","page":"Home","title":"Base.Filesystem.chmod","text":"chmod(fp::SystemPath, mode::Mode; recursive=false)\nchmod(fp::SystemPath, mode::Integer; recursive=false)\nchmod(fp::SystemPath, user::UIn8=0o0, group::UInt8=0o0, other::UInt8=0o0; recursive=false)\nchmod(fp::SystemPath, symbolic_mode::AbstractString; recursive=false)\n\nProvides various methods for changing the mode of a fp.\n\nExamples\n\njulia> touch(p\"newfile\")\nBase.Filesystem.File(false, RawFD(-1))\n\njulia> mode(p\"newfile\")\n-rw-r--r--\n\njulia> chmod(p\"newfile\", 0o755)\n\njulia> mode(p\"newfile\")\n-rwxr-xr-x\n\njulia> chmod(p\"newfile\", \"-x\")\n\njulia> mode(p\"newfile\")\n-rw-r--r--\n\njulia> chmod(p\"newfile\", user=(READ+WRITE+EXEC), group=(READ+EXEC), other=READ)\n\njulia> mode(p\"newfile\")\n-rwxr-xr--\n\njulia> chmod(p\"newfile\", mode(p\"src/FilePathsBase.jl\"))\n\njulia> mode(p\"newfile\")\n-rw-r--r--\n\n\n\n\n\n","category":"method"},{"location":"#FilePathsBase.TestPaths","page":"Home","title":"FilePathsBase.TestPaths","text":"TestPaths\n\nThis module is intended to be used for testing new path types to ensure that they are adhering to the AbstractPath API.\n\nExample\n\n# Create a PathSet\nps = PathSet(; symlink=true)\n\n# Select the subset of tests to run\n# Inspect TestPaths.TESTALL to see full list\ntestsets = [\n    test_constructor,\n    test_registration,\n    test_show,\n    test_parse,\n    test_convert,\n    test_components,\n    test_parents,\n    test_join,\n    test_splitext,\n    test_basename,\n    test_filename,\n    test_extensions,\n    test_isempty,\n    test_norm,\n    test_real,\n    test_relative,\n    test_abs,\n    test_isdir,\n    test_isfile,\n    test_stat,\n    test_size,\n    test_modified,\n    test_created,\n    test_cd,\n    test_readpath,\n    test_walkpath,\n    test_read,\n    test_write,\n    test_mkdir,\n    test_cp,\n    test_mv,\n    test_sync,\n    test_symlink,\n    test_touch,\n    test_tmpname,\n    test_tmpdir,\n    test_mktmp,\n    test_mktmpdir,\n    test_download,\n]\n\n# Run all the tests\ntest(ps, testsets)\n\n\n\n\n\n","category":"module"},{"location":"#FilePathsBase.TestPaths.PathSet","page":"Home","title":"FilePathsBase.TestPaths.PathSet","text":"PathSet(root::AbstractPath=tmpdir(); symlink=false)\n\nConstructs a common test path hierarchy to running shared API tests.\n\nHierarchy:\n\nroot\n|-- foo\n|   |-- baz.txt\n|-- bar\n|   |-- qux\n|       |-- quux.tar.gz\n|-- fred\n|   |-- plugh\n\n\n\n\n\n","category":"type"}]
}
